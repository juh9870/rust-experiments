use chumsky::prelude::*;
use crate::parser::{Span, Spanned, Token};

#[derive(Debug, Clone)]
pub enum Statement<'src> {
    Assignment(AssignmentTarget<'src>, Expression<'src>),
    NotImplemented,
}

#[derive(Debug, Clone)]
pub enum Expression<'src> {
    Num(f64),
    String(&'src str),
}

#[derive(Debug, Clone)]
pub enum AssignmentTarget<'src> {
    Simple(&'src str),
}

// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> = chumsky::input::SpannedInput<Token<'src>, Span, &'tokens [(Token<'src>, Span)]>;


fn expr_parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Statement<'src>>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> {
    return any().map_with_span(|_, s| (Statement::NotImplemented, s));
}