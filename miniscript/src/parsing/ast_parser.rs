use super::parser::{Keyword, Token};
use crate::ast::{
    BinaryOp, Body, Comparison, Expr, FunctionArgument, Path, Span, Spanned, Statement, UnaryOp,
    Value,
};
use chumsky::{combinator::SeparatedBy, prelude::*};

// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
// to understand.
type ParserInput<'tokens, 'src> =
    chumsky::input::SpannedInput<Token<'src>, Span, &'tokens [(Token<'src>, Span)]>;

fn parse_num(num: &str) -> f64 {
    num.parse()
        .unwrap_or_else(|_| panic!("Invalid number somehow slipped trough lexer: {num}"))
}

enum CallOrIndex<'src> {
    Call(Spanned<Vec<Spanned<Expr<'src>>>>),
    Index(Spanned<Expr<'src>>),
    Dot(Spanned<&'src str>),
}

macro_rules! binary_op {
    ($elem:ident, $op:expr) => {
        $elem
            .clone()
            .foldl($op.then($elem).repeated(), |a, (op, b)| {
                let span = a.1.start..b.1.end;
                (Expr::Binary(Box::new(a), op, Box::new(b)), span.into())
            })
            .boxed()
    };
}

macro_rules! unary_op {
    ($elem:ident, $op:expr) => {
        $elem
            .clone()
            .or($op.then($elem).map_with_span(|(op, b), span: Span| {
                let span = span.start..b.1.end;
                (Expr::Unary(op, Box::new(b)), SimpleSpan::from(span))
            }))
            .boxed()
    };
}

// macro_rules! rhs_unary_op {
//     ($elem:ident, $op:expr) => {
//         $elem
//             .clone()
//             .or($elem.then($op).map_with_span(|(b, op), span: Span| {
//                 let span = span.start..b.1.end;
//                 (Expr::Unary(op, Box::new(b)), SimpleSpan::from(span))
//             }))
//             .boxed()
//     };
// }

macro_rules! pre_eol {
    ($token:expr, $name:expr) => {
        just($token)
            .then_ignore(select_ref! { Token::Comment(_) => ()}.or_not())
            .then_ignore(just(Token::EOL).or_not())
    };
}

macro_rules! eol {
    () => {
        one_of([Token::EOL, Token::Semicolon]).labelled("EOL")
    };
}

macro_rules! end {
    ($expr:expr, $label:literal) => {
        just(Token::Keyword(Keyword::End)).ignore_then(just(Token::Keyword($expr)).or_not()).validate(|item, span, emitter| {
            if item.is_none() {
                emitter.emit(Rich::custom(span, format!("`end` statement must be followed by a name of control structure. Try `{}` instead", $label)))
            }
            ()
        }).labelled($label)
    };
}

macro_rules! identifier {
    () => {
        select_ref! { Token::Identifier(ident) => ident }.labelled("identifier")
    };
}

macro_rules! spanned_ref {
    ($expr:expr) => {
        $expr.map_with_span(|expr, span| (*expr, span))
    };
}
macro_rules! spanned {
    ($expr:expr) => {
        $expr.map_with_span(|expr, span| (expr, span))
    };
}

fn expr_parser<'tokens, 'src: 'tokens>(
    body: impl Parser<
            'tokens,
            ParserInput<'tokens, 'src>,
            Body<'src>,
            extra::Err<Rich<'tokens, Token<'src>, Span>>,
        > + Clone
        + 'tokens,
) -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Expr<'src>>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    recursive(|expr| {
        let val = select_ref! {
            Token::String(s) => Expr::Value(Value::String(s)),
            Token::Number(n) => Expr::Value(Value::Num(parse_num(n))),
            Token::Keyword(Keyword::False)=> Expr::Value(Value::Boolean(false)),
            Token::Keyword(Keyword::True)=> Expr::Value(Value::Boolean(true)),
            Token::Keyword(Keyword::Null)=> Expr::Value(Value::Null),
        }
        .labelled("value");

        // ,([{ can be followed by a line break
        let comma = pre_eol!(Token::Comma, ",");
        let l_paren = pre_eol!(Token::LParen, "(");
        let l_curly = pre_eol!(Token::LCurly, "{");
        let l_square = pre_eol!(Token::LSquare, "[");

        let ident = identifier!();

        let items = expr
            .clone()
            .separated_by(comma.clone())
            .allow_trailing()
            .collect::<Vec<_>>();

        let map_items = expr
            .clone()
            .then_ignore(just(Token::Colon))
            .then(expr.clone())
            .separated_by(comma.clone())
            .allow_trailing()
            .collect::<Vec<_>>();

        // A list of expressions
        let list = items
            .clone()
            .map(Expr::List)
            .delimited_by(l_square.clone(), just(Token::RSquare))
            .labelled("list");

        // A map of expression: expression
        let map = map_items
            .map(Expr::Map)
            .delimited_by(l_curly.clone(), just(Token::RCurly))
            .labelled("map");

        let function_arguments = spanned_ref!(ident.clone())
            .then(
                just(Token::OpAssign).ignore_then(
                    expr.clone()
                        .validate(|expr, span, emitter| {
                            if !expr.0.is_constant() {
                                emitter.emit(Rich::custom(
                                    span,
                                    "parameter default value must be a literal value",
                                ));
                            }
                            expr
                        })
                        .or_not(),
                ),
            )
            .map(|(name, default_value)| FunctionArgument {
                name,
                default_value,
            })
            .separated_by(comma.clone())
            .allow_trailing()
            .collect::<Vec<_>>();

        // Function definition
        let func = just(Keyword::Function.token())
            .ignore_then(
                function_arguments
                    .delimited_by(l_paren.clone(), just(Token::RParen))
                    .or_not(),
            )
            .then_ignore(eol!())
            .then(body)
            .map(|data: (Option<Vec<_>>, Body<'src>)| {
                Expr::FunctionDefinition(data.0.unwrap_or(vec![]), data.1)
            })
            .then_ignore(end!(Keyword::Function, "end function"));

        // A singular value
        let atom = spanned!(val
            // Chain
            .or(ident.map(|ident| Expr::Path(Path::AnyScope(ident))))
            // List
            .or(map)
            .or(list)
            .or(func))
        // Recursive parens (expression)
        .or(expr
            .clone()
            .delimited_by(l_paren.clone(), just(Token::RParen)))
        .map_with_span(|item, span| (item.0, span))
        // Attempt to recover anything that looks like a parens expression but contains errors
        .recover_with(via_parser(nested_delimiters(
            Token::LParen,
            Token::RParen,
            [
                (Token::LSquare, Token::RSquare),
                (Token::LCurly, Token::RCurly),
            ],
            |span| (Expr::Error, span),
        )))
        // Attempt to recover anything that looks like a list but contains errors
        .recover_with(via_parser(nested_delimiters(
            Token::LSquare,
            Token::RSquare,
            [
                (Token::LParen, Token::RParen),
                (Token::LCurly, Token::RCurly),
            ],
            |span| (Expr::Error, span),
        )))
        // Attempt to recover anything that looks like an object literal but contains errors
        .recover_with(via_parser(nested_delimiters(
            Token::LCurly,
            Token::RCurly,
            [
                (Token::LParen, Token::RParen),
                (Token::LSquare, Token::RSquare),
            ],
            |span| (Expr::Error, span),
        )))
        .boxed();

        // Call is the highest precedence
        let call = atom.foldl(
            items
                .clone()
                .delimited_by(l_paren.clone(), just(Token::RParen))
                .map_with_span(|args, span: Span| CallOrIndex::Call((args, span)))
                // .or(items.validate(|args, span: Span, emitter| {
                //     emitter.emit(Rich::custom(span, "function arguments must be surrounded by `(` and `)` when inside expressions"));
                //     CallOrIndex::Call((args, span))
                // }))
                .or(expr
                    .clone()
                    .delimited_by(l_square.clone(), just(Token::RSquare))
                    .map(CallOrIndex::Index))
                .or(just(Token::Dot)
                    .ignore_then(ident)
                    .map_with_span(|index, span| CallOrIndex::Dot((index, span))))
                .repeated(),
            |f, args| match args {
                CallOrIndex::Call(args) => {
                    let span = f.1.start..args.1.end;
                    (Expr::Call(Box::new(f), args.0), span.into())
                }
                CallOrIndex::Index(idx) => {
                    let span = f.1.start..idx.1.end;
                    (Expr::ExprIndex(Box::new(f), Box::new(idx)), span.into())
                }
                CallOrIndex::Dot(idx) => {
                    let span = f.1.start..idx.1.end;
                    (Expr::Index(Box::new(f), idx.0), span.into())
                }
            },
        );

        const BINARY_OP_LABEL: &'static str = "Binary operator";
        const UNARY_OP_LABEL: &'static str = "Unary operator";

        // Unsupoprted operators
        let op = one_of([Token::OpIncrement, Token::OpDecrement]).labelled(UNARY_OP_LABEL);
        let unsupported = op
            .clone()
            .or_not()
            .then(call.clone())
            .then(op.or_not())
            .validate(|((op_l, expr), op_r), span, emitter| {
                emitter.emit(Rich::custom(
                    span,
                    format!(
                        "Miniscript has no {} operator",
                        match (op_l, op_r) {
                            (None, None) => return expr,
                            (Some(Token::OpIncrement), _) => "prefix increment",
                            (Some(Token::OpDecrement), _) => "prefix decrement",
                            (_, Some(Token::OpIncrement)) => "postfix increment",
                            (_, Some(Token::OpDecrement)) => "postfix decrement",
                            _ => unreachable!(),
                        }
                    ),
                ));
                (Expr::Error, span)
            });

        // Power operator is the highest precedence after dot/call/index
        let op = just(Token::OpPower)
            .labelled(BINARY_OP_LABEL)
            .to(BinaryOp::Pow);
        let power = binary_op!(unsupported, op);

        // Address of
        let op = just(Token::AddressOf)
            .labelled(UNARY_OP_LABEL)
            .to(UnaryOp::AddressOf);
        let address_of = unary_op!(power, op);

        // `New` operator
        let op = just(Keyword::New.token())
            .labelled(UNARY_OP_LABEL)
            .to(UnaryOp::New);
        let new = unary_op!(address_of, op);

        // `Negation` operator
        let op = just(Token::OpMinus)
            .labelled(UNARY_OP_LABEL)
            .to(UnaryOp::Neg);
        let unary_minus = unary_op!(new, op);

        // Product ops (multiply and divide) have equal precedence
        let op = just(Token::OpTimes)
            .labelled(BINARY_OP_LABEL)
            .to(BinaryOp::Mul)
            .or(just(Token::OpDivide)
                .labelled(BINARY_OP_LABEL)
                .to(BinaryOp::Div));
        let product = binary_op!(unary_minus, op);

        // Sum ops (add and subtract) have equal precedence
        let op = just(Token::OpMinus)
            .labelled(BINARY_OP_LABEL)
            .to(BinaryOp::Sub)
            .or(just(Token::OpPlus)
                .labelled(BINARY_OP_LABEL)
                .to(BinaryOp::Add));
        let sum = binary_op!(product, op);

        // Comparison operators have special rules
        let op = choice((
            just::<_, _, extra::Err<Rich<'tokens, Token<'src>, Span>>>(Token::OpEqual)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::Eq),
            just(Token::OpNotEqual)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::NotEq),
            just(Token::OpGreater)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::Gt),
            just(Token::OpLesser)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::Lt),
            just(Token::OpGreatEqual)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::GtEq),
            just(Token::OpLessEqual)
                .labelled(BINARY_OP_LABEL)
                .to(Comparison::LtEq),
        ));

        let comp = sum
            .clone()
            .then(op.then(sum.clone()).repeated().collect::<Vec<_>>())
            .map_with_span(|(lhs, chain), span: Span| {
                if chain.is_empty() {
                    return lhs;
                }
                return (Expr::Comparison(Box::new(lhs), chain), span);
            });

        // Isa operator
        let op = just(Keyword::Isa.token())
            .labelled(UNARY_OP_LABEL)
            .to(UnaryOp::Isa);
        let isa = unary_op!(comp, op);

        // Not operator
        let op = just(Keyword::Not.token())
            .labelled(UNARY_OP_LABEL)
            .to(UnaryOp::Not);
        let not = unary_op!(isa, op);

        // And and Or operators have lowest precedence
        let op = just(Keyword::And.token())
            .labelled(BINARY_OP_LABEL)
            .to(BinaryOp::And);
        let and = binary_op!(not, op);

        let op = just(Keyword::Or.token())
            .labelled(BINARY_OP_LABEL)
            .to(BinaryOp::Or);
        let or = binary_op!(and, op);

        or.boxed()
    })
}

pub fn parser<'tokens, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Vec<Spanned<Statement<'src>>>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    recursive(|body| {
        let comma = pre_eol!(Token::Comma, ",");
        let expr = expr_parser(body.clone().boxed());

        let if_then = just(Keyword::If.token())
            .ignore_then(expr.clone())
            .then(just(Keyword::Then.token()).or_not())
            .validate(|item, span, emitter| {
                if item.1.is_none() {
                    emitter.emit(Rich::custom(
                        span,
                        "if statement must be followed by `then`",
                    ))
                }
                (item.0, span)
            });
        let token_else = just(Keyword::Else.token());

        let single_line = recursive(|single_line| {
            // Simlpe <expr> = <expr> assignment.
            let assignment = expr
                .clone()
                .validate(|expr, span, emitter| {
                    if !expr.0.is_valid_assignment_target() {
                        emitter.emit(Rich::custom(span, "invalid assignment target"));
                    }
                    expr
                })
                .then_ignore(just(Token::OpAssign))
                .then(expr.clone())
                .map_with_span(|(lhs, rhs), span| (Statement::Assignment(lhs, rhs), span))
                .labelled("assignment");

            // A singular expression

            // A function call without parentheses, or a single expression
            let function_call = expr
                .clone()
                .then(
                    expr.clone()
                        .separated_by(comma)
                        .allow_trailing()
                        .collect::<Vec<_>>(),
                )
                .map_with_span(|(target, args), span| {
                    if args.is_empty() {
                        return (Statement::Expression(target), span);
                    }
                    let call_expr = Expr::Call(Box::new(target), args);
                    (Statement::Expression((call_expr, span)), span)
                });

            // Single line if-else
            let single_line_if = if_then
                .clone()
                .then(single_line.clone())
                .then(
                    token_else
                        .clone()
                        .ignore_then(single_line.clone().validate(
                            // See https://github.com/JoeStrout/miniscript/issues/86
                            |statement: Spanned<Statement>, span: SimpleSpan, emitter| {
                                if matches!(statement.0, Statement::If(..)) {
                                    emitter.emit(Rich::custom(span, "`else` in a single line `if` statement can't be followed by another `if` statement"));
                                }
                                statement
                            },
                        ))
                        .or_not(),
                )
                .map_with_span(|((condition, expression), statement_else), span| {
                    (
                        Statement::If(
                            vec![(condition, vec![expression])],
                            statement_else.map(|e| vec![e]),
                        ),
                        span,
                    )
                });

            let control_flow = choice((
                just(Keyword::Break.token()).to(Statement::Break),
                just(Keyword::Continue.token()).to(Statement::Continue),
                just(Keyword::Return.token())
                    .ignore_then(expr.clone().or_not())
                    .map(Statement::Return),
            ));

            assignment
                .or(function_call)
                // .or(expression)
                .or(single_line_if)
                .or(spanned!(control_flow))
                .boxed()
        });

        // Multiline `if` statement
        let if_part = if_then.clone().then_ignore(eol!()).then(body.clone());
        // Starts with a single `if <condition> then; <body>`
        let multiline_if = if_part
            .clone()
            // Followed by any amount of `else if <condition> then; <body>`
            .then(
                just(Keyword::Else.token())
                    .ignore_then(if_part.clone())
                    .repeated()
                    .collect::<Vec<_>>(),
            )
            // Optionally followed by a single `else; <body>`
            .then(
                just(Keyword::Else.token())
                    .ignore_then(body.clone())
                    .or_not(),
            )
            // And closed by `end if`
            .then_ignore(end!(Keyword::If, "end if"))
            .map_with_span(|((main, mut rest), body_else), span| {
                rest.insert(0, main);
                (Statement::If(rest, body_else), span)
            });

        // While statement. `while <condition>; <body>; end while`
        let while_statement = spanned!(just(Keyword::While.token()).ignore_then(expr.clone()))
            .then_ignore(eol!())
            .then(body.clone())
            .then_ignore(end!(Keyword::While, "end while"))
            .map_with_span(|(condition, body), span| (Statement::While(condition, body), span));

        // For statement. `for <ident> in <expr>; <body>; end for`
        let for_statement = just(Keyword::For.token())
            .ignore_then(spanned_ref!(identifier!()))
            .then_ignore(just(Keyword::In.token()))
            .then(expr.clone())
            .then_ignore(eol!())
            .then(body.clone())
            .then_ignore(end!(Keyword::For, "end for"))
            .map_with_span(|((ident, condition), body), span| {
                (Statement::For(ident, condition, body), span)
            });

        let multi_eol = eol!().repeated().at_least(1);
        return single_line
            .or(multiline_if)
            .or(while_statement)
            .or(for_statement)
            .separated_by(multi_eol.clone())
            .collect()
            .delimited_by(multi_eol.clone().or_not(), multi_eol.clone().or_not());
    })
}
